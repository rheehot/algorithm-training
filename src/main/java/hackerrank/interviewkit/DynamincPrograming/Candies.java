package main.java.hackerrank.interviewkit.DynamincPrograming;

import java.lang.reflect.Array;
import java.util.Arrays;

/**
 * https://www.hackerrank.com/challenges/candies
 * 2, 4, 2, 6, 1, 7, 8, 9, 2, 1
 * 위와 같은 학생의 점수가 있다
 * 2, 4 비교 다음 수가 크니 2가 가진 사탕개수 보다 높은 사탕을 준다(최소 사탕개수이니 +1)
 * 4, 2 비교 다음 수가 작으니 4가 가진 사탕개수 보다 낮은 사탕을 준다(최소 사탕개수이니 1개 준다)
 * 2, 2 두 학생의 점수가 같은 경우도 최소 사탕 개수를 준다 1개
 *
 * 다만 예외 적으로 9, 2 , 1 의 경우에
 *  9 2
 *  3 1 => 2가 9보다 작으므로 1개의 캔디를 주면
 *  2 1
 *  1 0 => 2 다음에 1이 작은 수이므로 적은 수의 캔디를 줘야하는데 그러면 0이 되기 때문에
 *  2 에게 1개를 주면 안 되고 9보다 작은 캔디지만 1보다는 큰 캔디를 줘야한다
 *  이 의미는 2 다음의 수들이 어떤 상황인지 파악 되어야 함
 *
 *  해결책은
 *  일단 루프를 돌면서 다음 수가 큰경우 지금 숫자+1, 아닌경우 1 로 맞춘다
 *  처음 은 무조건 1
 *  2, 4, 2, 6, 1, 7, 8, 9, 2, 1
 *  아래와 같이 된다
 *  1, 2, 1, 2, 1, 2, 3, 4, 1, 1
 *
 *  그리고 역순으로 루프를 돌리는데 2, 1 => 역순으로 1 다음 수인  2가 큰경우가 생기면 1의 캔디 개수에 +1 값과 , 원래 루프를 돌린결과 2의 의 캔디 개수 1 중
 *  놓은 캔디 개수로 맞추고 8, 9 처럼  역순으로 9 다음 수 8 이 작은 경우는 원래 루프 돌면서 맞춰진 값을 그대로 사용한다
 *  2, 4, 2, 6, 1, 7, 8, 9, 2, 1
 *  1, 2, 1, 2, 1, 2, 3, 4, 1, 1
 *
 *  2 > 1 에서 2가 크므로 1의 캔디 1+1 와 원래 루프 2의 캔디 수 1 중 2를 채운다
 *  9 > 2 2+1, 4 중 4가 크므로 교채 필요없다
 *  8 < 9 8이 작으므로 교채 필요 없다
 *  ...
 *  4 > 2 1+1, 2 같다 교채 대상인데 교채 안한거나 마찬가지
 *
 *  결국
 *  2, 4, 2, 6, 1, 7, 8, 9, 2, 1
 *  1, 2, 1, 2, 1, 2, 3, 4, 1, 1 = 18
 *  1, 2, 1, 2, 1, 2, 3, 4, 2, 1 = 19 (정답)
 */
public class Candies {
    public static long candies(int n, int[] arr) {
        long sum = 0;
        int[] a = new int[arr.length];
        a[0] = 1;

        for (int i = 1; i < arr.length; i++) {
            a[i] = arr[i - 1] < arr[i] ? a[i - 1] + 1 : 1;
        }

        for (int i = arr.length-1; i > 0 ; i--) {
            a[i-1] = (arr[i - 1] > arr[i]) ? Math.max(a[i - 1], a[i]+1) : a[i-1];
            sum+=a[i];
        }

        return sum+a[0];
    }
}
