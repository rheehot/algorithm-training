package hackerrank.interviewkit.DynamincPrograming;

import java.util.Arrays;

/**
 * https://www.hackerrank.com/challenges/candies
 * [Candies]
 * [MEDIUM]
 * 2, 4, 2, 6, 1, 7, 8, 9, 2, 1
 * 위와 같은 학생의 점수가 있다, 최소 사탕개수는 1개
 * 첫번 째 2는 최소 사탕 개수 1을 가진다.
 * 2, 4 비교 4의 사탕개수는 2보다 크니 2의 사탕개수 + 1  = 2 개
 * 4, 2 비교 2의 사탱개수는 4보다 작으니 최소사탕을 준다   = 1 개
 * 2, 2 두 학생의 점수가 같은 경우도 최소 사탕 개수를 준다  = 1개
 *
 * 예외 적으로 9, 2, 1 의 경우가 있는데 좀 애매한 조건이다.
 * 이 조건 때문에 dp로 깔금하게 푸는 문제가 아닌듯 그냥 greedy 알고리즘을 앞 -> 뒤, 뒤 -> 앞 으로
 * 처리해 주는 기법으로 해결한다 아래 예를 보
 *  9, 2, 1 의 경우
 *  9 의 캔디는 죽 계산되어 4 이고
 *  9,2 경우 원래 조건에 의해서 2가 구보다 작아서 캔디는 1이 되어야하고
 *  2,1 경우 1이 2보다 작아서 1이 되어야 하는데
 *  9, 2, 1
 *  4  1  1 => 원래 조건이면 이렇게 캔디 개수가 나와야 하는데
 *  4  2  1 => 이게 정답 이다 그래서 현재 수가 앞수 보다 크면 앞수 캔디 개수+1, 아니면 1 이 아니라 다른 조건이 또 생겨 버린다....
 *
 *
 *
 *  해결책은
 *  일단 루프를 돌면서 다음 수가 큰경우 지금 숫자+1, 아닌경우 1 로 맞춘다
 *  처음 은 무조건 1
 *  2, 4, 2, 6, 1, 7, 8, 9, 2, 1
 *  아래와 같이 된다
 *  1, 2, 1, 2, 1, 2, 3, 4, 1, 1
 *
 *  그리고 역순으로 루프를 돌리는데 2, 1 => 역순으로 1 다음 수인  2가 큰경우가 생기면 1의 캔디 개수에 +1 값과 , 원래 루프를 돌린결과 2의 의 캔디 개수 1 중
 *  놓은 캔디 개수로 맞추고 8, 9 처럼  역순으로 9 다음 수 8 이 작은 경우는 원래 루프 돌면서 맞춰진 값을 그대로 사용한다
 *  2, 4, 2, 6, 1, 7, 8, 9, 2, 1
 *  1, 2, 1, 2, 1, 2, 3, 4, 1, 1
 *
 *  2 > 1 에서 2가 크므로 1의 캔디 1+1 와 원래 루프 2의 캔디 수 1 중 2를 채운다
 *  9 > 2 2+1, 4 중 4가 크므로 교채 필요없다
 *  8 < 9 8이 작으므로 교채 필요 없다
 *  ...
 *  4 > 2 1+1, 2 같다 교채 대상인데 교채 안한거나 마찬가지
 *
 *  결국
 *  2, 4, 2, 6, 1, 7, 8, 9, 2, 1
 *  1, 2, 1, 2, 1, 2, 3, 4, 1, 1 = 18
 *  1, 2, 1, 2, 1, 2, 3, 4, 2, 1 = 19 (정답)
 */
public class Candies {
    public static long candies(int n, int[] arr) {
        long sum = 0;
        int[] a = new int[arr.length];
        a[0] = 1;

        for (int i = 1; i < arr.length; i++) {
            a[i] = arr[i - 1] < arr[i] ? a[i - 1] + 1 : 1;
        }

        for (int i = arr.length-1; i > 0 ; i--) {
            a[i-1] = (arr[i - 1] > arr[i]) ? Math.max(a[i - 1], a[i]+1) : a[i-1];
            sum+=a[i];
        }

        return sum+a[0];
    }



}
